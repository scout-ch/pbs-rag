# Based on docker compose .env file

# Global image pull secrets configuration
imagePullSecrets: []

env:
  # The version of Elasticsearch.
  STACK_VERSION: "8.11.3"

  # The password for Elasticsearch
  ELASTIC_PASSWORD: infini_rag_flow_helm

  # The host of the MySQL server
  MYSQL_HOST:
  # The password for MySQL
  MYSQL_PASSWORD: infini_rag_flow_helm
  # The database of the MySQL service to use
  MYSQL_DBNAME: rag_flow

  # The username for MinIO.
  MINIO_ROOT_USER: rag_flow
  # The password for MinIO
  MINIO_PASSWORD: infini_rag_flow_helm

  # The password for Redis
  REDIS_PASSWORD: infini_rag_flow_helm

  # The local time zone.
  TIMEZONE: "Europe/Zurich"

  # Uncomment the following line if you have limited access to huggingface.co:
  # HF_ENDPOINT: https://hf-mirror.com

  # The maximum file size for each uploaded file, in bytes.
  # You can uncomment this line and update the value if you wish to change 128M file size limit
  # MAX_CONTENT_LENGTH: "134217728"
  # After making the change, ensure you update `client_max_body_size` in nginx/nginx.conf correspondingly.

  # The number of document chunks processed in a single batch during document parsing.
  DOC_BULK_SIZE: 4

  # The number of text chunks processed in a single batch during embedding vectorization.
  EMBEDDING_BATCH_SIZE: 16

ragflow:
  image:
    repository: infiniflow/ragflow
    tag: v0.20.4-slim
    pullPolicy: IfNotPresent
    pullSecrets: []
  # Optional service configuration overrides
  # to be written to local.service_conf.yaml
  # inside the RAGFlow container
  # https://ragflow.io/docs/dev/configurations#service-configuration
  service_conf:
    oauth:
      midata:
        display_name: MiData
        client_id:
        client_secret:
        issuer: "https://pbs.puzzle.ch"
        scope: openid email
        redirect_uri: #"https://hostname/v1/user/oauth/callback/midata"

  # Optional yaml formatted override for the
  # llm_factories.json file inside the RAGFlow
  # container.
  llm_factories:
    # factory_llm_infos:
    # - name: OpenAI-API-Compatible
    #   logo: ""
    #   tags: "LLM,TEXT EMBEDDING,SPEECH2TEXT,MODERATION"
    #   status: "1"
    #   llm:
    #     - llm_name: my-custom-llm
    #       tags: "LLM,CHAT,"
    #       max_tokens: 100000
    #       model_type: chat
    #       is_tools: false

  # Kubernetes configuration
  deployment:
    strategy:
    resources:
  service:
    # Use LoadBalancer to expose the web interface externally
    type: ClusterIP
  api:
    service:
      enabled: true
      type: ClusterIP

elasticsearch:
  image:
    repository: elasticsearch
    tag: "8.11.3"
    pullPolicy: IfNotPresent
    pullSecrets: []
  initContainers:
    alpine:
      repository: alpine
      tag: latest
      pullPolicy: IfNotPresent
    busybox:
      repository: busybox
      tag: latest
      pullPolicy: IfNotPresent
  storage:
    className:
    capacity: 20Gi
  deployment:
    singleNode: true
    antiAffinity: "soft"
    esJavaOpts: "-Xmx96m -Xms96m"
    image: docker.elastic.co/elasticsearch/elasticsearch-oss
    resources:
      requests:
        memory: "500Mi"
        cpu: "100m"
      limits:
        memory: "1Gi"
        cpu: "800m"
  service:
    type: ClusterIP

minio:
  image:
    repository: quay.io/minio/minio
    tag: RELEASE.2023-12-20T01-00-02Z
    pullPolicy: IfNotPresent
    pullSecrets: []
  storage:
    className:
    capacity: 5Gi
  deployment:
    strategy:
    resources:
  service:
    type: ClusterIP

redis:
  image:
    repository: valkey/valkey
    tag: 8
    pullPolicy: IfNotPresent
    pullSecrets: []
  storage:
    className:
    capacity: 5Gi
  persistence:
    enabled: true
    # Set's the retention policy for the persistent storage (only available in k8s 1.32 or later)
    # https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#persistentvolumeclaim-retention
    # retentionPolicy:
      # whenDeleted: Delete
      # whenScaled: Delete
  deployment:
    strategy:
    resources:
  service:
    type: ClusterIP


# This block is for setting up web service ingress. For more information, see:
# https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  className: ""
  annotations:
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    traefik.ingress.kubernetes.io/router.entrypoints: websecure # necessary, since we have multiple entrypoints
    traefik.ingress.kubernetes.io/router.tls.certresolver: letsencrypt
  host: ""
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local
